<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
namespace DiscriminatedUnions
{
	using System;
	using System.Linq;
    using System.Collections.Generic;
<#
var maxNumberOfTypeArguments = 10;
#>
    /// <summary>
    /// Provides extension methods to the IEnumerable of DiscriminatedUnion.
    /// </summary>
	public static class DiscriminatedUnionIEnumerableExtensions
	{
<#	    
for(var numberOfArguments = 2; numberOfArguments <= maxNumberOfTypeArguments -1; numberOfArguments +=1)
{
#>        /// <summary>
        /// Merges to given collections into a discriminated union collection.
        /// </summary>
<#for(var i = 0; i < numberOfArguments; i +=1)
		{
#>        /// <typeparam name="Type<#= i + 1 #>">Type<#= i + 1 #></typeparam>
<#
}
#>
<#for(var i = 0; i < numberOfArguments; i +=1)
		{
#>        /// <param name="type<#= i + 1 #>Values">a collection to merge</param>
<#
}
#>
        /// <returns>Discriminated unions of all types.</returns>
        public static IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>> Merge<<#= TypeArgumentsFor(numberOfArguments) #>>(this IEnumerable<Type1> type1Values, <#= ArgumentsFor("IEnumerable<Type{0}> type{0}Values, ", numberOfArguments, 1)#>)
        {
<#
for(var i = 0; i < numberOfArguments; i +=1)
{
#>
            foreach (var type<#= i + 1 #>Value in type<#= i + 1 #>Values)
            {
                yield return new DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>(type<#= i + 1 #>Value);
            }
<#
}
#>
        }

		public static void Match<<#= TypeArgumentsFor(numberOfArguments) #>>(this IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>> values,  <#= ActionArgumentsFor(numberOfArguments) #>)
        {
			foreach(var item in values)
			{
			    item.Match(
<#for(var i = 0; i < numberOfArguments -1; i +=1)
{
#>
                type<#= i + 1 #>Item => Action<#= i + 1 #>(type<#= i + 1 #>Item),
<#
}
#>
                type<#= numberOfArguments #>Item => Action<#= numberOfArguments #>(type<#= numberOfArguments #>Item));
			}
        }

        public static IEnumerable<ReturnType> Match<<#= TypeArgumentsFor(numberOfArguments) #>, ReturnType>(this IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>> values,<#= FunctionArgumentsFor(numberOfArguments) #>)
        {
			foreach(var item in values)
			{
				yield return item.Match(
				<#for(var i = 0; i < numberOfArguments -1; i +=1)
{
#>
                type<#= i + 1 #>Item => Function<#= i + 1 #>(type<#= i + 1 #>Item),
<#
}
#>
                type<#= numberOfArguments #>Item => Function<#= numberOfArguments #>(type<#= numberOfArguments #>Item));
            }
	    }


        /// <summary>
        /// Merges the item into the existing discriminatedunions resulting in a new enumerable of discriminated unions with the type of the item as a new option.
        /// </summary>
<#for(var i = 0; i < numberOfArguments; i +=1)
		{
#>        /// <typeparam name="Type<#= i + 1 #>">Type<#= i + 1 #></typeparam>
<#
}
#>
        /// <param name="values">existing Discriminated unions</param>
        /// <param name="item"></param>
        /// <returns></returns>
        public static IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments + 1) #>>> Merge<<#= TypeArgumentsFor(numberOfArguments + 1) #>>(this IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>> values, Type<#= numberOfArguments + 1 #> item)
        {
			return values.Merge((IEnumerable<Type<#= numberOfArguments + 1#>>)new List<Type<#= numberOfArguments + 1#>>{ item });
		}

		/// <summary>
        /// Merges the item intos the existing discriminatedunions resulting in a new enumerable of discriminated unions with the type of the items as a new option.
        /// </summary>
<#for(var i = 0; i < numberOfArguments; i +=1)
		{
#>        /// <typeparam name="Type<#= i + 1 #>">Type<#= i + 1 #></typeparam>
<#
}
#>
        /// <param name="values">existing Discriminated unions</param>
        /// <param name="items"></param>
        /// <returns></returns>
        public static IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments + 1) #>>> Merge<<#= TypeArgumentsFor(numberOfArguments + 1) #>>(this IEnumerable<DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments) #>>> values, IEnumerable<Type<#= numberOfArguments + 1 #>> items)
        {
            foreach (var item in values)
            {
			     yield return item.Match(
<#for(var i = 0; i < numberOfArguments -1; i +=1)
{
#>
                     type<#= i + 1 #>Item => new DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments + 1) #>>(type<#= i + 1 #>Item),
<#
}
#>
                     type<#= numberOfArguments #>Item => new DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments + 1) #>>(type<#= numberOfArguments #>Item));
            }
            foreach (var item in items)
            {
                yield return new DiscriminatedUnion<<#= TypeArgumentsFor(numberOfArguments + 1) #>>(item);
            }
        }
<#
}
#>

    }
}
<#+
public string TypeArgumentsFor(int numberOfArguments)
{
	var result = "";
	for(var i = 0; i < numberOfArguments; i+=1)
	{
		result += String.Format("Type{0}, ",i + 1);
	}
	return result.Trim(' ').Trim(',');
}

public string FunctionArgumentsFor(int numberOfArguments)
{
	var result = "";
	for(var i = 0; i < numberOfArguments; i+=1)
	{
		result += String.Format("Func<Type{0}, ReturnType> Function{0}, ",i + 1);
	}
	return result.Trim(' ').Trim(',');
}

public string ActionArgumentsFor(int numberOfArguments)
{
	var result = "";
	for(var i = 0; i < numberOfArguments; i+=1)
	{
		result += String.Format("Action<Type{0}> Action{0}, ",i + 1);
	}
	return result.Trim(' ').Trim(',');
}

public string ArgumentsFor(string format, int numberOfArguments, int start = 0)
{
	var result = "";
	for(var i = start; i < numberOfArguments; i+=1)
	{
		result += String.Format(format,i + 1);
	}
	return result.Trim(' ').Trim(',');
}
#>